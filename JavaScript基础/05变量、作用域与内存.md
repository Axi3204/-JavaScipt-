## 原始值与引用值

**原始值 ：** Undefined, null, boolean, number, string, symbol
**引用值：** 由多个值构成的对象
原始值是**按值**访问的，引用值是**按引用**访问的。

## 动态属性
原始值不能有属性，引用值可以随时添加、修改、删除属性
```js
let person1 = '张三'; //这是原始值
person1.name = '李四'; //报错

let person2 = {}; //这是引用值
person2.name = '李四'; //不会报错
```

## 复制值
原始值与其复制的值是完全独立的，互不干扰。
引用值的复制是复制变量的地址。

## 传递参数
ECMAScript中所有函数的参数传递都是**按值传递**。

## 执行上下文（重要）
**什么是执行上下文：** 就是当前JS代码被解析和执行时存在的环境。（抽象概念，并不是实际的环境）

**执行上下文的类型**
- 全局执行上下文
（1）不在函数内部的代码都位于全局执行上下文
（2）会创建一个全局对象，即window对象
（3）将this指针指向这个对象
- 函数执行上下文
（1）每个函数都有自己的执行上下文
（2）每次函数被**调用**的时候就会创建函数执行 上下文。
（3）一个程序可以存在多个函数执行上下文
（4）每一个函数执行上下文被创建，它都会按照特定的顺序执行一些列的步骤
- eval 函数执行上下文

**执行上下文的生命周期**
创建阶段——执行阶段——回收阶段
1. 创建阶段：
当函数被调用，但是未执行内部代码前，会做这几件事：
- 创建变量对象： 首先 会初始化函数的参数arguments, 然后提升函数声明和变量声明
- 创建作用域链： 作用域链是在创建变量对象后进行创建的，作用域链本身包含变量对象，作用域链用来解析变量
- 确定this指向
2. 执行阶段
执行变量赋值等操作、执行代码
3. 回收阶段
执行上下文出栈，等待虚拟机回收

**补充：变量提升与函数提升**
**注意：** 同名的函数和变量被提升的时候，函数声明的优先级 高于 变量声明， 变量声明会被函数声明覆盖， 但变量声明可以重新赋值。
```js
console.log(f1);//[Function: f1] 函数声明覆盖变量声明
var f1 = 'this is a variable';
function f1() { 
   alter('this is a function');
}

console.log(f1)//this is a variable , 尽管f1赋值在函数f1()前，但同名变量可以重新赋值
```
