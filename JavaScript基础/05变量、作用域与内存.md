## 原始值与引用值

**原始值 ：** Undefined, null, boolean, number, string, symbol
**引用值：** 由多个值构成的对象
原始值是**按值**访问的，引用值是**按引用**访问的。

## 动态属性
原始值不能有属性，引用值可以随时添加、修改、删除属性
```js
let person1 = '张三'; //这是原始值
person1.name = '李四'; //报错

let person2 = {}; //这是引用值
person2.name = '李四'; //不会报错
```

## 复制值
原始值与其复制的值是完全独立的，互不干扰。
引用值的复制是复制变量的地址。

## 传递参数
ECMAScript中所有函数的参数传递都是**按值传递**。

## 执行上下文（重要）
**什么是执行上下文：** 就是当前JS代码被解析和执行时存在的环境。（抽象概念，并不是实际的环境）

**执行上下文的类型**
- 全局执行上下文
（1）不在函数内部的代码都位于全局执行上下文
（2）会创建一个全局对象，即window对象
（3）将this指针指向这个对象
- 函数执行上下文
（1）每个函数都有自己的执行上下文
（2）每次函数被**调用**的时候就会创建函数执行 上下文。
（3）一个程序可以存在多个函数执行上下文
（4）每一个函数执行上下文被创建，它都会按照特定的顺序执行一些列的步骤
- eval 函数执行上下文

**执行上下文的生命周期**
创建阶段——执行阶段——回收阶段
1. 创建阶段：
当函数被调用，但是未执行内部代码前，会做这几件事：
- 创建变量对象： 首先 会初始化函数的参数arguments, 然后提升函数声明和变量声明
- 创建作用域链： 作用域链是在创建变量对象后进行创建的，作用域链本身包含变量对象，作用域链用来解析变量
- 确定this指向
2. 执行阶段
执行变量赋值等操作、执行代码
3. 回收阶段
执行上下文出栈，等待虚拟机回收

**补充：变量提升与函数提升**
**注意：** 同名的函数和变量被提升的时候，函数声明的优先级 高于 变量声明， 变量声明会被函数声明覆盖， 但变量声明可以重新赋值。
```js
console.log(f1);//[Function: f1] 函数声明覆盖变量声明
var f1 = 'this is a variable';
function f1() { 
   alter('this is a function');
}
console.log(f1)//this is a variable , 尽管f1赋值在函数f1()前，但同名变量可以重新赋值
```

## 作用域链增强
某些语句会导致在作用域链前端临时添加一个上下文，这个上下文会在代码执行后被删除。
- try/catch语句中catch块
- with语句

## 变量声明
**var**
 var声明变量时会自动添加到最接近的上下文。在函数中，最接近的上下文就是函数上下文，如果变量未声明就被初始化，那么它就会被添加到全局上下文（通俗地讲：变量没有var声明就直接赋值，这个赋值就是全局变量）。

**let**
- let和const声明的变量是块级作用域（块级作用域是由最近的一对包含花括号{ }界定的）。
- let在同一作用域不能重复声明
- let循环非常适合在循环中声明迭代变量，var声明的迭代变量会泄露到全局作用域中。
```js
for(var i = 0 ; i <= 5; i++) {
   console.log(i);
}
console.log(i)//6 在全局中可以访问到迭代变量
```

**const**
声明常量。
实践表明：开发流程中，应该尽可能地用const声明

## 垃圾回收机制（重要）
思路： 确定哪个变量不再使用，然后释放它占用的内存。
- 垃圾回收机制是周期性的，会每隔一段时自动运行
- 垃圾回收程序必须记录哪一个变量不会使用，哪一个变量还会继续使用，需要对变量进行标记。 标记策略主要有两种：
  （1）标记清理
  （2）引用计数

## 性能
垃圾回收程序会周期性地运行，如果内存中分配了很多变量，则可能造成性能损失。

## 内存管理
优化内存的最佳手段：保证在执行代码时，只保存必要的数据。如果数据不再必要，就把它设置成null, 从而释放引用，这个方法叫做**解除引用**
**注意：**解除引用并不是自动回收相关内存，而是确保该变量不在当前上下文中，因此它会在下一次垃圾回收时被回收。

**提升性能**
- 通过const、let声明提升性能
  - const和let都是块级作用域，相较于var，可能会更早地让垃圾回收程序介入
- 隐藏类和删除操作
- 内存泄露 
- 静态分配与对象池

